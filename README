--------------------------------------------------------------------------------
DDTS
--------------------------------------------------------------------------------

Quick Start

  ddts <suite>                          : run the suite named <suite>
  ddts gen-baseline <dir> <suite>       : run <suite>, write baseline to <dir>
  ddts use-baseline <dir> <suite>       : run <suite>, compare to baseline <dir>
  ddts clean                            : remove most test-suite created items
  ddts help                             : shows this usage information
  ddts run [ gen-baseline <dir> ] <run> : do <run>, write baseline to <dir>
  ddts run [ use-baseline <dir> ] <run> : do <run>, compare to baseline <dir>
  ddts show build <build>               : show details of the build <build>
  ddts show builds                      : show valid build names
  ddts show run <run>                   : show details of the run <run>
  ddts show runs                        : show valid run names
  ddts show suite <suite>               : show details of the suite <suite>
  ddts show suites                      : show valid suite names
  ddts version                          : print version number and exit

* Note that either an 'app' directory must exist alongside the 'ddts' wrapper
  script, or the environment variable DDTSAPP must be defined (with the path to
  a directory containing the required configuration files as its value) to run
  ddts. See the 'Configuration' section, below, for details.

--------------------------------------------------------------------------------
1. Baseline Creation / Comparison
--------------------------------------------------------------------------------

Run 'ddts gen-baseline <dir> <suite>' to create a baseline image of the named
suite ('ddts show suites' lists valid names). A set of output from the suite's
runs will be written to the directory named by <dir>, which will be created if
necessary. One subdirectory will be created under <dir> for each unique
'baseline' value specified in the configs of the suite's various runs. These
subdirectories must not already exist.

Run 'ddts use-baseline <dir> <suite>' to compare the output produced by a new
suite invocation to the existing baseline in <dir>.

A useful workflow might consist of these steps:

  1. Check out a fresh working copy.
  2. Run 'ddts gen-baseline <dir> <suite>' to generate a baseline.
  3. Make changes to the working copy as needed.
  4. Run 'ddts use-baseline <dir> <suite>' to verify your changes.

--------------------------------------------------------------------------------
2. Logging
--------------------------------------------------------------------------------

Each 'ddts' invocation that does not fail immediately generates a verbose
logfile named 'log.timestamp', where timestamp is the seconds-since-epoch test-
suite start time. Logfiles are created under $DDTSAPP/logs (see the next section
for information on DDTSAPP).

--------------------------------------------------------------------------------
3. Configuration
--------------------------------------------------------------------------------

A DDTS application requires, in addition to the core driver in ts.rb, the
following, which must appear either in a (possibly symlinked) directory named
'app', alongside ts.rb; or in a directory named by the environment variable
'DDTSAPP' (where the latter, if defined, takes precedence):

- An implementation of library.rb. See below, and the example application in
  the directory 'ex', for reference.

- YAML build, run and suite configuration files, in the 'builds', 'runs', and
  'suites' subdirectories, respectively, of the $DDTSAPP/configs directory.

The configuration files in the 'builds', 'runs' and 'suites' directories are
expressed in YAML. They are parsed by the core driver and instantiated as hash
and array containers. An 'env' environment object is passed in as the first
argument to each library method (see section 5). The 'build', 'run' and 'suite'
members of the env object expose the contents of their respective configs -- as
well as items that may be added by the library implementer -- as OpenStruct
objects, for easy access.

3.1 Build Configs
-----------------

Build configs contain the information necessary to construct a command to
perform a build via the external build-automation system. Their content, then,
depends on the requirements of that system and the interface to it defined in
library methods. Like run configs (see section 3.2, below), build configs can be
composed via the 'extends' key.

Keys prefixed with 'lib_' are reserved, and provide a per-build mechanism for
overriding library methods.

3.2 Run Configs
---------------

Run configs contain the information necessary to prepare, configure, execute and
verify runs; to associate them with baseline images; etc. Config contents will
depend on the model and platform, but several top-level keys are reserved:

- [required] The 'baseline' key specifies the name of the baseline image
  into which this run's output should be copied (when baseline generation is
  requested), or against which it should be verified (when baseline comparison
  is requested). Runs whose output is expected to be identical should share a
  common 'baseline' value. To exclude a run from baseline participation, specify
  the value 'none'.

- [required] The 'build' key specifies the name of the build (i.e. the filename
  of a build config) to use for this run.

- [optional] The 'extends' key specifies the name of a run config from which
  the current config should inherit, and which it may override. Rrecursion is
  supported, but loops are fatal errors.

- [optional] The 'require' key specifies the name of a run or the names of runs
  on which this run depends. The value may be a scalar string (for a single
  required run), or an array of strings. A run will wait until its required runs
  have completed before starting, and may access those runs' results via the
  env.run._require_results key.

- Keys prefixed with 'lib_', which provide a per-run mechanism for overriding
  library methods, are reserved.

3.3 Suite Configs
-----------------

Each outer, array element in a suite config names a group of runs expected to
produce identical output, whose output will be compared together via some
comparison criterion (bitwise identity, by default). Inner array elements
are the names of runs (i.e. filenames of run configs).

Each outer, scalar element in a suite config represents a suite-level
configuration parameter.

The following reserved keys (suite-level configuration paramters) are available:

- [optional] The 'build_only' key, defined with any true value, indicates
  that the builds required by the suite should be performed, but that all
  subsequent runs and comparisons should be skipped.

- [optional] The 'continue' key, defined with any true value, will allow the
  test suite to continue running even if some components (e.g. comparisons
  of output, or entire runs) fail.

- [optional] The 'retain_builds' key, defined with any true value, indicates
  that the core driver should rebuild over existing builds without deleting
  them first. This should generally be considered unsafe.

- Keys prefixed with 'lib_', which provide a per-suite (or per-comparison-group)
  mechanism for overriding library methods, are reserved.

NOTE that any suite-config items whose values are arrays will be interpreted
as run group definitions. Those whose values are scalars will be interpreted
as suite-level configuration parameters. Custom parameters may be be added, and
will appear in the env.suite object passed into library methods.

3.4 Other Reserved Keys
-----------------------

In addition to those already listed, key names beginning with an underscore
are reserved. In particular, the following keys are made available by the
core driver to library methods. Recommended library methods from which to
access these keys are given. Access may be possible from other methods, but
access from other than the recommended methods should handle errors (i.e.
nil values).

- env._dlog: The delayed (file) logger object. Access recommended from method
  lib_suite_post. For expert use only: Logging should be done via Utility
  methods logd and logi.

- env._ilog: The immediate (screen) logger object. Access recommended from
  method lib_suite_post. For expert use only: Logging should be done via
  Utility methods logd and logi.

- env.build._result: The final value returned from lib_build_post. Access
  recommended from method lib_run*.

- env.build._root: The path to a unique directory reserved for this build.
  It is recommended, but not required, that the build be performed under
  this directory, which will be created automatically by the core drive for
  use by library methods. Access recommended from method lib_build*.

- env.run._name: The name of the run, as reported e.g. in log entries. Access
  recommended from method lib_run*.

- env.run._require_results: A hash mapping the names of runs on which this run
  was defined to require to the results of those runs.

- env.suite._runs: A hash mapping run names to the object returned by the
  lib_run_post method. Access recommended from method lib_suite_post. This value
  is final only in lib_suite_post, and only for suite (not single-run)
  invocations.

- env.suite._suitename: The name of the running suite, as given on the command
  line. Access recommended from method lib_suite*, and only for suite (not
  single-run) invocations.

- env.suite._totalfailures: The number of runs that failed, either when
  executing or in comparison of their output against another run or against
  a baseline. Access recommended from method lib_suite_post. This value is final
  only in lib_suite_post, and only for suite (not single-run) invocations.

- env.suite._totalruns: The number of runs executed by the test suite. Access
  recommended from method lib_suite_post. This value is final only in
  lib_suite_post library method, and only for suite (not single-run)
  invocations.

--------------------------------------------------------------------------------
4. Quoting Rules for Fortran Namelists
--------------------------------------------------------------------------------

If namelist editing is to be performed, please note that, in general, values
recognized as strings in YAML are instantiated as Ruby String objects. Some
caveats:

- YAML casts some unquoted strings to primitive data types. For example, the
  unquoted word 'yes' will be instantiated as a Ruby 'true' boolean. There are
  a number of similar cases. When casting yields unwated behavior, explicitly
  quote the problematic value in the config. A conservative solution is to
  quote all strings.

- The YAML library would normally print Ruby string objects without enclosing
  quotes, whether or not they are quoted in the config. For example, values
  abc, 'abc' and "abc" would all be printed without quotes. The core driver
  adds single quotes around all String values when writing Fortran namelists
  so that, for the previous example, all three values would appear as 'abc'
  (i.e. in single quotes). Sometimes this isn't what's needed. For example,
  the Fortran primitive value .true. will be recognized by YAML as a string,
  but must appear unquoted in a namelist. To support this, a value may be
  preceded by the tag !unquoted in a YAML config to suppress quoting of that
  value. For example, the YAML entries

    gribout: !unquoted  .true.
    gribout: !unquoted '.true.'
    gribout: !unquoted ".true."

  would all result in the Fortran namelist entry

    gribout=.true.

- Values recognized as numbers will be written without quotes. If quotes are
  desired, explicitly quote the value in the config so that it is recognized
  as a string.

--------------------------------------------------------------------------------
5. Library
--------------------------------------------------------------------------------

library.rb contains methods defining the interface between the test suite and
the model and platform. Section 5.1, below, describes the methods called by the
core driver.

Library methods should not use instance variables. Communication with the core
driver or with other library methods should be done either via the passed-in
'env' object, or via the objects returned by certain library methods. Section
5.1 discusses the return values expected from library methods and how they are
used by the core driver. The 'env' OpenStruct object has .build, .run and .suite
members that expose the contents of the respective configs. New members may be
added to env.[build|run|suite], or to env itself, as needed. Note that, while
changes made to the top-level env object and its .suite member from TS objects
(see call-order table in section 5.1) are visible in the subordinate Comparison
and Run objects, changes made by Comparison and Run objects are confined to
those objects.

5.1 Model/Platform Methods
--------------------------

These methods are called directly by the core driver. An environment object (see
section 3) is passed in as the first argument to each library method; it may be
inspected in each method to determine what information it contains.

A Library module with default (and mostly useless) implementations of these
methods is provided by defaults.rb, which is loaded automatically by the core
driver for all applications. If $DDTSAPP/library.rb exists, it will also be
loaded, with the methods contained in its Library module overriding those in
defaults.rb. Finally, as described below for each library method, special keys
in suite, run and build configs may override both library.rb and defaults.rb
definitions, specifying alternate method names for each standard library method
name. See the 'ex' application for examples.

The library methods are called in the following order:

 # Calling Object  Method            Notes
-- -------------- ------------------ -------------------------------------------
 1 TS             lib_suite_prep
 2 Run            lib_build_prep
 3 Run            lib_build
 4 Run            lib_build_post
 5 Run            lib_data
 6 Run            lib_run_prep
 7 Run            lib_run
 8 Run            lib_run_post
 9 Run            lib_run_check
10 Run            lib_outfiles
11 Run            lib_comp           When 'use-baseline' is specified
12 Comparison     lib_comp           When comparison group contains > 1 run
13 TS             lib_suite_post

Additionally, lib_queue_del_cmd may be called asynchronously for any job whose
ID has been registered via a call to Utility#job_activate.

Description of library methods:

lib_build(env)

  Performs the build described by env.build.

  Returns an arbitrary object, which is passed to lib_build_post; the object's
  type and value should be determined by the needs of that method.

  May be aliased to an alternate library method via the 'lib_build' key in a run
  config.

lib_build_post(env,buildkit)

  Performs any actions necessary after a build completes. The object returned by
  the lib_build method is received as the 'buildkit' argument.

  Returns an arbitrary object containing whatever is needed for a run to make
  use of the build results. For example, the object may contain (among other
  things), the path to a directory containing the runtime files necessary to
  perform a run. This object will be made available to each run using this
  build via env.build._result.

  If the build fails to return, env.build._result will contain the :build_failed
  symbol.

  May be aliased to an alternate library method via the 'lib_build_post' key in
  a run config.

lib_build_prep(env)

  Takes any actions required prior to performing a build.

  Return value is unused.
  
  May be aliased to an alternate library method via the 'lib_build_prep' key in
  a run config.

lib_comp(env,file1,file2)

  Performs a comparison between file1 and file2.

  Returns true if comparison was deemed successful, false otherwise.

  May be aliased to an alternate library method via the 'lib_comp' key in a
  suite config. NOTE: The 'lib_comp' key should be specified under each
  comparison group that requires a special comparator. If lib_comp is left
  undefined, FileUtils.compare_file is used.

lib_data(env)

  Takes actions necessary to make input data available for the suite. Called
  once per test-suite invocation.

  Return value is unused.
  
  May be aliased to an alternate library method via the 'lib_data' key in a run
  config.

lib_outfiles(env,path)

  Returns an array containing the pathnames of the files that will be (1)
  added to this run's baseline if one is being produced; (2) compared against
  an existing baseline, if baseline comparison is being performed; and (3)
  compared against comparable runs. The 'path' argument specifies a directory
  under which the run's unique output can be found. Each entry in the returned
  array is in the form [path1,path2], where path1+path2 forms the absolute
  path to an output file, and path2 is the suffix of the path that is (a) the
  same across runs in the comparison group; and (b) what should be stored in a
  baseline image.

  May be aliased to an alternate library method via the 'lib_outfiles' key in a
  run config.

lib_queue_del_cmd(env)

  Returns a string containing the name of the external program to run to delete
  a job from the queue system, given its ID as an argument.

  May be aliased to an alternate library method via the 'lib_queue_del_cmd' key
  in a run config.

lib_run(env,rundir)

  Performs a run.

  Returns an arbitrary object, which is passed to lib_run_post; the object's
  type and value should be determined by the needs of that method.

  May be aliased to an alternate library method via the 'lib_run' key in a run
  config.

lib_run_check(env,postkit)

  Returns a true or false value indicating whether the run suceeded or failed.
  The 'postkit' argument contains the object returned by the lib_run_post
  method.

  May be aliased to an alternate library method via the 'lib_run_check' key in
  a run config.

lib_run_post(env,runkit)

  Takes any actions necessary following a successful run, before the test suite
  proceeds to output comparision. The 'runkit' argument contains the object
  returned by the lib_run method.

  Returns an arbitrary object containing whatever is needed (1) to determine
  whether the run succeeded or failed, and (2) for any suite-level purposes
  identified by the library implementer.

  May be aliased to an alternate library method via the 'lib_run_post' key in a
  run config.

lib_run_prep(env,rundir)

  Takes any actions required prior to starting a run. The 'rundir' argument
  contains the name of a unique directory to be used by this run.

  Returns a string containing the path to the directory where the run should
  be started (perhaps via queue submission). This may be the same 'rundir' as
  was passed in, or something else.

  May be aliased to an alternate library method via the 'lib_run_prep' key in a
  run config.

lib_suite_post(env)

  Take any actions necessary after a successful test-suite execution. The
  passed-in env object has no .build or .run members, only .suite.

  Return value is unused.

  May be aliased to an alternate library method via the 'lib_suite_post' key in
  a suite config.

lib_suite_prep(env)

  Take any actions necessary prior to the builds, runs and comparisons defined
  by the test suite. The passed-in env object has no .build or .run members,
  only .suite.

  Return value is unused.

  May be aliased to an alternate library method via the 'lib_suite_prep' key in
  a suite config.

Other methods useful to a specific model or platform may be provided by the
library implementer as needed. See uses of Utility#invoke in ts.rb for examples
of how to override such custom methods via build, run and suite configs.

5.2 Utility Methods
-------------------

The core driver provides a number of utility methods that may be useful in the
implementation of library methods:

app_dir

  Returns the root path of the current application.

die(msg)

  Attempts to delete any jobs queued to the batch system, and prints/logs the
  (optional) 'msg' argument's String value. Terminates the test suite (unless
  'continue' mode is active) by raising an exception, and so does not return.

ext(cmd,props)

  Executes, in a subshell (/bin/sh under Linux), the command contained in the
  String 'cmd'. Returns a two-element Array composed of (1) an Array of the
  command's combined stdout and stderr streams, and (2) the command's integer
  exit status.

  The (optional) 'props' Hash may contain the following key/value pairs:

    :die

    Terminates the suite if the shell command sets a non-zero exit status.
    True by default.

    :msg

    If :die is true, :msg's String value will be printed/logged before exit.

    :out

    If :out is true, the shell command's output (combined stdout/stderr)
    will be logged to the verbose logfile (but not to the screen). True by
    default.

hash_matches(file,hash)

  Returns true if the MD5 checksum of the file identified by the 'file' String
  matches the MD5 checksum contained in String 'hash', and false otherwise.

home_dir

  Returns the root path of the test-suite core driver.

invoke(std,key,*args)

  Symbol argument 'std' names a library method. Symbol argument 'key' names a
  config type. The *args are the arguments to be passed to the named library
  method (the first of *args MUST be the 'env' object). If the config named by
  'key' defines an alias for the method named by 'std', it is called; otherwise,
  'std' is called. In either case, *args are passed as arguments. For example,
  'invoke(:lib_comp,:run,env,x)' would result in the call 'lib_comp_alt(env,x)'
  if the run config contained 'lib_comp: lib_comp_alt'.

job_activate(jobid,run)

  Register's the given 'jobid' as having been submitted to the batch system
  for the Run objet referenced by the 'run' argument. The list of registered
  job IDs is used to delete jobs from the batch system when the test suite
  fails. The supplied job ID should be the appropriate argument to the program
  identified by the lib_queue_del_cmd library method.

job_check(stdout,restr)

  Returns true if a regular expression instantiated from the 'restr' String
  argument matches any line in the file identified by the 'stdout' argument,
  and false otherwise.

job_deactivate(jobid)

  De-registers the given 'jobid' from the list of batch-system jobs. See
  job_activate(), above, for more information.

logd(msg)

  Log the 'msg' argument's String value to the delayed (file) logger.

logfile

  Returns the path to the logfile.

logi(msg)

  Log the 'msg' argument's String value to the immediate (screen) logger, and
  to the delayed (file) logger.

logw(msg)

  Like logi(), but prefixes 'msg' with the text "WARNING!" and, on successful
  completion of the test suite, prints/logs a reminder about the warning. It
  may be useful to warn users about issues not deemed serious enough to halt
  the test suite.

tmp_dir

  The path to a temporary directory, which will be removed by the 'clean'
  command.

valid_dir(dir)

  A convenience wrapper to ensure that the directory named by argument 'dir'
  actually exists. Calls die() with an appropriate message if the directory
  does not exist. For example, 'd=valid_dir(File.join(a,b,c))' would set 'd'
  if and only if the path constructed from 'a', 'b' and 'c' exists.

valid_file(file)

  Same as valid_dir(), but for a file argument.

--------------------------------------------------------------------------------
Environment Variables
--------------------------------------------------------------------------------

In addition to DDTSAPP, discussed above, the following environment variables are
used by ddts:

DDTSHOME: Specifies the path to the root directory of the ddts installation. It
is set automatically by the 'ddts' wrapper script.

DDTSOUT: Specifies the directory into which all automatically-generated test-
suite output should be written. If DDTSOUT is not set, DDTSAPP's value is used.
