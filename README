
--------------------------------------------------------------------------------
DDTS
--------------------------------------------------------------------------------

Quick Start

  ddts <suite>            : run the suite named <suite>
  ddts baseline <suite>   : run the suite named <suite> & create baseline image
  ddts clean              : remove most test-suite created items
  ddts cleaner            : clean + remove baseline & data archive
  ddts help               : shows this usage information
  ddts run <run>          : perform the single run named <run>
  ddts show run <run>     : show details of the run named <run>
  ddts show runs          : show valid run names
  ddts show suite <suite> : show details for the suite named <suite>
  ddts show suites        : show valid suite names

* Note that a 'conf' directory must exist, or the environment variable DDTSCONF
  defined (with the path to a directory containing the required configuration
  files as its value) to run ddts. See the 'Configuration' section, below, for
  details.

Baseline Creation / Comparison

  Run 'ddts baseline <suite>' to create a baseline image of the named suite
  ('ddts show suites' lists valid names). A directory named 'baseline' will be
  created in the current directory, and one subdirectory will be created under
  it for each unique 'baseline' value specified in the configs of the suite's
  various runs. These subdirectories must not already exist.

  The test suite will automatically compare its runs' output to the contents of
  the 'baseline' directory if it exists. You may copy or link a previously
  generated baseline directory here.

A useful workflow might consist of these steps:

  1. Check out a fresh working copy.
  2. Run 'ddts baseline <suite>' to generate a baseline.
  3. Make changes to the working copy as needed.
  4. Run 'ddts <suite>' to verify your changes against the baseline.

Logging

  Each 'ddts' invocation that does not fail immediately generates a verbose
  logfile named 'log.timestamp', where timestamp is the seconds-since-epoch
  test-suite start time.

--------------------------------------------------------------------------------
Configuration
--------------------------------------------------------------------------------

  A DDTS implementation requires, in addition to the core driver in ts.rb, the
  following, which must appear either in a (possibly symlinked) directory named
  'conf', alongside ts.rb; or in a directory named by the environment variable
  'DDTSCONF' (where the latter, if defined, takes precedence):

  - An implementation of library.rb: See below, and the example implementation
    in the directory 'ex', for reference.

  - An implementation of profiles.rb: See below, and the example implementation
    in the directory 'ex', for reference.

  - YAML build, run and suite configuration files, in subdirectories 'builds',
    'runs', and 'suites', respectively. See below for reference.

  The configuration files in the 'builds', 'run's and 'suites' directories are
  are expressed in YAML. They are parsed by the core driver and instantiated as
  hash and array containers. Inside Run objects and the methods they call, an
  'env' environment object is available whose 'build', 'run' and 'suite' members
  expose the contents of their respective configs, as well as items that may be
  added by the library implementer, as OpenStruct objects.

  - Build configs are represented as the YAML equivalents of nested hashes, and
    contain the information necessary to construct a command to perform a build
    via the external build-automation system. Their content, then, depends on
    the requirements of that system and the interface to it defined in the core
    driver and library. Like run configs (see below), build configs can be
    composed via the 'extends' key.

  - Run configs are represented as the YAML equivalents of nested hashes, and
    contain the information necessary to prepare, configure, execute and verify
    a run; to associate it with a baseline image; etc. Config contents will
    depend on the model and platform, but several top-level keys are reserved:

    - [required] The 'baseline' key specifies the name of the baseline image
      into which this run's output should (potentially) be copied, or against
      which this run's output should be compared. Runs whose output is expected
      to be identical should share a common 'baseline' value. To exclude a run
      from baseline participation, specify the value 'none'.

    - [required] The 'build' key specifies the name of the build (i.e. the
      filename of a build config) to use for this run.

    - [optional] The 'extends' key specifies the name of a run config from which
      the current config should inherit, and which is may override. Rrecursion
      is supported, but loops are fatal errors.

    - [optional] The 'profile' key specifies the name of a Ruby module (defined
      in profiles.rb) that may be used to alias required method names to
      platform-specific versions in library.rb. Due to Ruby naming rules,
      'profile' values must begin with an upper-case letter. If no profile is
      specified, the Library module will be loaded as-is, with no aliasing
      performed.

  - Suite configs are represented as the YAML equivalent of a hash of arrays
    and strings. Each outer array element names a group of runs expected to
    produce identical output, whose output will be compared together for bitwise
    identity. Inner array elements are the names of runs (i.e. filenames of run
    configs).

    The following reserved keys are available:

    - [optional] The 'build_only' key, defined with any true value, indicates
      that the builds required by the suite should be performed, but that all
      subsequent runs and comparisons should be skipped.

    - [optional] The 'continue' key, defined with any true value, will allow the
      test suite to continue running even if some components (e.g. comparisons
      of output, or entire runs) fail.

    - [optional] The 'profile' key behaves the same as its run-config namesake.

    - [optional] The 'retain_builds' key, defined with any true value, indicates
      that the core driver should rebuild over existing builds without deleting
      them first.

  - In addition to those already listed, key names beginning with an underscore
    are reserved. In particular, the following keys are made available by the
    core driver to library methods:

    - env.build._result: The final value returned by the run thread that
      performs a build.

    - env.build._root: The path to the directory under which the run should
      perform its build. Composed of the top-level directory containing all
      builds performed for the test suite, and a subdirectory with the same
      name as the build config.

    - env.run._name: The name of the run, as reported e.g. in log entries.

    - env.suite._dlog: The delayed (file) logger object.

    - env.suite._ilog: The immediate (screen) logger object.

    - env.suite._totalfailures: The number of runs that failed, either when
      executing or in comparison of their output against another run or against
      a baseline. This value is final only in the lib_suite_post library method.

    - env.suite._totalruns: The number of runs executed by the test suite. This
      value is final only in the lib_suite_post library method.

    NOTE that any suite-config items whose values are arrays will be interpreted
    as run group definitions. Those whose values are scalars will be interpreted
    as suite-level settings.

  - Running the test suite with arguments 'show suite <suite_name>' or
    'show run <run_name>' will show the complete form of a suite or run config,
    respectively, including ancestry. The commands 'show runs' and 'show suites'
    show complete list of those items.

Quoting Rules for Fortran Namelists

  If namelist editing is to be performed, please note that, in general, values
  recognized as strings in YAML are instantiated as Ruby String objects. Some
  caveats:

  - YAML casts some unquoted strings to primitive data types. For example, the
    unquoted word 'yes' will be instantiated as a Ruby 'true' boolean. There are
    a number of similar cases. When casting yields unwated behavior, explicitly
    quote the problematic value in the config. A conservative solution is to
    quote all strings.

  - The YAML library would normally print Ruby string objects without enclosing
    quotes, whether or not they are quoted in the config. For example, values
    abc, 'abc' and "abc" would all be printed without quotes. The core driver
    adds single quotes around all String values when writing Fortran namelists
    so that, for the previous example, all three values would appear as 'abc'
    (i.e. in single quotes). Sometimes this isn't what's needed. For example,
    the Fortran primitive value .true. will be recognized by YAML as a string,
    but must appear unquoted in a namelist. To support this, a value may be
    preceded by the tag !unquoted in a YAML config to suppress quoting of that
    value. For example, the YAML entries

      gribout: !unquoted  .true.
      gribout: !unquoted '.true.'
      gribout: !unquoted ".true."

    would all result in the Fortran namelist entry

      gribout=.true.

  - Values recognized as numbers will be written without quotes. If quotes are
    desired, explicitly quote the value in the config so that it is recognized
    as a string.

--------------------------------------------------------------------------------
Profiles
--------------------------------------------------------------------------------

  library.rb contains methods defining the interface between the test suite and
  the model and platform. profiles.rb contains modules used to extend individual
  test-suite Run objects with appropriate library methods. Each such module
  starts by including all of the library methods as defaults, then defines
  aliases for any methods for which the default must be overridden. The section
  'Model/Platform Methods', below, describes the methods called by the core
  driver. Each must be implemented.

  Library methods should not use instance variables. Communication with the core
  driver or with other library methods may be done either via method arguments,
  or via the passed-in 'env' environment object. (The 'env' OpenStruct object
  has .build, .run and .suite members that expose the contents of the respective
  configs) New members may be added to env.[build|run|suite], or to env itself,
  as needed.)

Model/Platform Methods

  These methods are called directly by the core driver. An environment object
  (see above) is passed in as the first argument to each method; it may be
  inspected in each method to determine what information it contains.

  Other methods useful to a specific model or platform may be implemented as
  needed.

  lib_build(env)

    Returns an array, potentially containing build output or other data, to be
    passed to lib_build_post(); the actual contents should be determined by the
    needs of that method. Performs the build described by env.build, or halts
    the test suite if the build fails.

  lib_build_post(env,output)

    Returns a string containing the path to a directory that should be copied
    into the test suite's 'runs' directory to be used by a single run. An array
    of strings (possibly representing the output from the build) is provided via
    the 'output' argument.

  lib_build_prep(env)

    Return value is unused. Takes any actions required prior to performing the
    build.

  lib_data(env)

    Return value is unused. Takes actions necessary to create, populate, verify,
    etc., in the top-level test-suite directory, a 'data' directory containing
    data files to be used by the test-suite runs. To allow for automated clean-
    up, if this method places a data-archive file in the top-level test-suite
    directory, it should be named 'data.tgz'; if a data directory is created, it
    should be named 'data'.

  lib_outfiles(env,path)

    Returns an array containing the pathnames of the files that will be (1)
    added to this run's baseline if one is being produced; (2) compared against
    an existing baseline, if baseline comparison is being performed; and (3)
    compared against comparable runs. The 'path' argument specifies a directory
    under which the run's unique output can be found. Each entry in the returned
    array is in the form [path1,path2], where path1+path2 forms the absolute
    path to an output file, and path2 is the suffix of the path that is (a) the
    same across runs in the comparison group; and (b) what should be stored in a
    baseline image.

  lib_queue_del_cmd(env)

    Returns a string containing the name of the external program to run to
    delete a job from the queue system, given its ID as an argument.

  lib_run(env,rundir)

    Returns a single object that will be passed to lib_run_post, which may use
    it for any purpose, including determining whether the run succeeded or
    failed. Performs a run.

  lib_run_post(env,runkit)

    Returns a true or false value indicating whether the run succeeded or failed.
    The runkit argument contains the object returned by the lib_run method. Take
    any actions necessary following a successful run, before the test suite
    proceeds to output comparision, and determines run success/failure.

  lib_run_prep(env,rundir)

    Returns a string containing the path to the directory where the run should
    be started (perhaps via queue submission). Takes any actions required prior
    to starting the run. The 'rundir' argument contains the name of a unique
    directory to be used by this run.

  lib_suite_post(env)

    Return value is unused. Take any actions necessary after a successful test-
    suite execution. The passed-in env object has no .build or .run members,
    only .suite.

  lib_suite_prep(env)

    Return value is unused. Take any actions necessary prior to performing the
    builds, runs and comparisons defined by the test suite. The passed-in env
    object has no .build or .run members, only .suite.

