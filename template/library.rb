module Library

  # REQUIRED METHODS (CALLED BY DRIVER)

  # GENERAL GUIDELINES:
  # Familiarize oneself with reserved suite, run, and build level keywords
  # Keep in mind that this module is included in a "profile" that is 
  # incorporated into the core classes.  As such it will have access
  # to core defined functions. For instance, logging functions of the core such as 
  # "logi" and "logd" maybe used as well as the shell execution "ext"
  # Finally, arbitrary variables can be introduced into the env structure so predominantly
  # passed to the functions. And YAML variables are stored in the env strucutre under
  # their respective suite, run or build locations.
  # 

  # Use this method for general suite actions not particularly connected with anyone 
  # specific build or run.
  # Note: env contains only .suite members
  def lib_suite_prep(env)
  end

  # Use this method to setup the build environment. Typically the source code  
  # staging location is updated from repository and copied to this build's 
  # private location.  The variable env.build._root contains the location of the build directory.
  # Caution: Builds are multithreaded and as such may compete for the same
  # source directory when said directory is shared. Use of Thread.exclusive do end
  # block mitigates this problem
  def lib_build_prep(env)
    # 1. Construct the name of the build directory and store it in the env.build
    # structure for later reference. The value of env.build._root is supplied
    # internally by the test suite; the value of env.run.build is supplied by
    # the run config.
    #ex: env.build.dir=env.build._root
    # 2. Construct the path to the source files. Wrapping in valid_dir() (defined
    # in ts.rb) ensures that it actually already exists.
    #ex: srcdir=valid_dir(File.join("..","src"))
    # 3. Pull code from repository into source directory established earlier
    #ex: cmd="cd #{srcdir} && git pull git://github.com/... <branch>"
    #    ext(cmd,{:msg=>"Pull failed, see #{logfile}"})
    # 4. Copy the source files, recursively, into the build directory.
    #ex: FileUtils.cp_r(srcdir,env.build.dir)
    #    logd "Copied #{srcdir} -> #{env.build.dir}"
    # 5. Process additional build level variables such as linking the 
    # correct top-level makefile.
    #ex: src=env.build.makefile_top
    #    dst=File.join(env.build.dir,"GNUmakefile")
    #    FileUtils.ln_sf(src,dst)
    #    logd "Linked top-level makefile: #{dst} -> #{src}"
  end

  # Use this method to lauch the build process. The framework allows only
  # one thread to run this method per build specification. This coordination
  # prevents wasted effort of building the same thing multiple times.
  # Note that the returned value (the result of the last statement in the
  # function) is passed as input to the lib_build_post method
  def lib_build(env)
    # 1. Construct the build command
    #ex: cmd="cd #{env.build.dir} && make"
    # 2. Execute the build command
    #ex: ext(cmd,{:msg=>"Build failed, see #{logfile}"})
  end

  # Use this method to wrap up the build process. output will contain
  # lib_build's return value. This method's return value is stored in 
  # the env.build._result variable and can be globally used by all
  # run methods that share this build 
  def lib_build_post(env,output)
    # 1. Sanity check output
    # 2. Move executables into a directory of their own.
    #ex: bindir=File.join(env.build.dir,"bin")
    #      FileUtils.mkdir_p(bindir)
    #      [
    #        <executablename1>,
    #        <executablename2>
    #      ].each do |x|
    #      FileUtils.mv(File.join(env.build.dir,x),bindir)
    #      logd "Moved #{x} -> #{bindir}"
    #    end
    # 3. Return result which in this case will be the location of the executables
    #ex: bindir
  end

  # Use this method to prepare the input data required for all runs 
  # of this suite. This method is therefore executed only once.
  def lib_data(env)
    # 1. Copy/download input set
    # 2. Decompress input
    #ex: nothing to do in our case
    #    logd "No data-prep needed."
  end

  # Use this method to prepare a run for execution. This tipically includes 
  # copying the appropriate executable files from the build directory into the 
  # rundir directory.  rundir is generated by the framework to be a unique
  # location under the runs directory.  This variable maybe used or one's
  # own location could be utilized.  However, if a new location is used,
  # rundir must be updated to reflect this change.  For that reason the
  # return value of this method must be the run directory.
  def lib_run_prep(env,rundir)
    # 1. Copy executable dir into run directory using env.build._result
    #ex: FileUtils.cp_r(env.build._result,rundir)
    #    logd "Copied #{env.build._result} -> #{rundir}"
    # 2. Since the executables are in a subdirectory of the run directory, update
    # rundir to reflect this.
    #ex: rundir=File.join(rundir,File.basename(env.build._result))
    # 3. Link data.
    #ex: datadir=valid_dir(File.join("..","data"))
    #    [
    #      <inputname1>,
    #      <inputname2>,
    #      <inputname3>
    #    ].each { |x| FileUtils.ln_sf(File.join(datadir,x),rundir) }
    # 4. -VERY IMPORTANT- Return rundir (i.e. where to perform the run).
    #ex: rundir
  end

  # Use this method to execute the specific run from the rundir location or
  # any subdirectory within it. It is paramount that the returned value
  # identify the file containing the run's exit status
  def lib_run(env,rundir)
    # 1. Construct the command to execute in a subshell to perform the run.
    #ex: cmd="cd #{rundir} && <executablename> > stdout"
    # 2. Execute external command via ext() (defined in ts.rb).
    #ex: ext(cmd,{:msg=>"Run failed, see #{logfile}"})
    # 3. -VERY IMPORTANT- Return the path to the file that contains
    # the run's completion status.
    # ex: File.join(rundir,"stdout")
  end

  # Use of this method is mandatory in order to signal the framework that a
  # run completed successfully.  It must return either true or false for
  # success or failure respectively. 
  def lib_run_post(env,runkit)
    # This example uses job_check which searches a file for a regex match
    logd "Verifying run success..."
    stdout=runkit
    # Here re_str_success further generalizes the regex string and 
    # should the user require be aliased in the profiles.rb file
    (job_check(stdout, re_str_success))?(true):(false)
  end

  # Used this method to return the data structure that describes the 
  # expected output of this run.  The structure is an array of arrays
  # each internal array is composed of two items.  The path of the file
  # and the file name.  The variable path passed into this function
  # contains the run directory's location which can be used to identify
  # the location of the output.  This expected output is used for 
  # comparison and creation of the baseline. 
  def lib_outfiles(env,path)
    #ex:
    #[
    #  [path,<output1>],
    #  [path,<output2>],
    #  [path,<output3>]
    #]
  end

  # When running the suite in failfast (i.e. no continue=true entry) mode
  # runs registered through job_activate(jobid,run) that have not yet finished and
  # removed themselves by calling job_deactivate(jobid) are then removed from 
  # the system via the command provided bellow.  It is expected that the command
  # takes the jobid as a parameter
  def lib_queue_del_cmd(env)
    #ex: the do nothing call 
    #    nil
    #ex: the PBS queue delete command
    #   'qdel'
  end

  # The string provided bellow is used by jobcheck(stdout) to identify that a
  # run completed successfully.  The file returned by lib_run is searched for this
  # particular string
  def lib_re_str_success(env)
    #ex:
    #   "Status: success"
  end

  # This method is called after all runs have completed
  def lib_suite_post(env)
    # 1. Perform cleanup
    # 2. Email notification
    #ex:
    #    suite_name=env.suite._suitename
    #    email_from=env.suite.email_from
    #    email_to=env.suite.email_to
    #    email_subject=env.suite.email_subject
    #    email_server=env.suite.email_server
    #    email_ready=true if email_server and email_from and email_to and email_subject
    #    if env.suite._totalfailures > 0
    #      msg="#{env.suite._totalfailures} TEST(S) OUT OF #{env.suite._totalruns} FAILED"
    #      subject="#{email_subject} -- #{suite_name} (FAILED)"
    #      send_email(email_from,email_to,subject,email_server,msg,true) if email_ready
    #    else
    #      msg="ALL TESTS PASSED"
    #      subject="#{email_subject} -- #{suite_name} (COMPLETED)"
    #      send_email(email_from,email_to,subject,email_server,msg,false) if email_ready
    #    end

  end

  # -- CUSTOM METHODS (NOT CALLED BY DRIVER) --
  # Additional methods can be included here

  # ex: a helper function to the lib_run_post method:
  def re_str_success
    "<Some success string here>"
  end

  #ex: the send_email method:
  def send_email(from,to,subject,server,body,include_log)

    marker= "alksjdhf7400297143627990123" #Used to separate sections of a multi-part email

    #Compose email header
    #'to' can be a single email string, a comma separated multi email strings, or a string array
    to_mod = nil
    if to.class == String
      to_mod = to.split(",").map { |x| "<#{x}>"}.join(",")
    else
      to_mod=to.map { |x| "<#{x}>" }.join(",")  if to.respond_to?('map')
    end

    header=<<EOF
From: #{from}
To: #{to_mod}
Subject: #{subject}
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary=#{marker}

--#{marker}
EOF
    #Compose email body
    my_body=<<EOF
Content-Type: text/plain
Content-Transfer-Encoding:8bit

#{body}
EOF

    message=header + my_body

    if include_log
      #Compose Email attachment
      logfilename=logfile()
      logcontent=File.read(logfilename)
      encodedcontent = [logcontent].pack("m")  #base64 encoding
      attachment=<<EOF
Content-Type: multipart/mixed; name=\"#{logfilename}.txt\"
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="#{logfilename}.txt"

#{encodedcontent}
EOF

      message+=("--#{marker}\n"+ attachment + "--#{marker}--\n")
    else
      message+="--#{marker}--\n"
    end

    begin
      f=File.open("#{logfilename}.txt","w")
      f.write(message)
    rescue IOError => e
    ensure
      f.close unless f == nil
    end

    to_array=nil
    if to.class == String
      to_array= to.split (",")
    else
      to_array= to.map { |x| x} if to.respond_to?('map')
    end
    to_array.each do |recipient|
      begin
        Net::SMTP.start(server) do |smtp|
          smtp.send_message message, from, recipient
        end
      rescue Exception => e
        logi "Email exception occurred: #{e}"
      end
    end
  end

end
